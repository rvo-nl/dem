let RLDCurveCategories,residualLoadDurationCurveStackgraphConfig = {stackElements: [{indicator: 'Electrolysis',data: 'ELECTROLYSIS',color: '#3c39cc'}, {indicator: 'Electricity export',data: 'ELECTRICITY_EXPORT',color: '#42a5f5'}, {indicator: 'Nuclear',data: 'NUCLEAR',color: '#1DE9B6'}, {indicator: 'WKK',data: 'ELECTRICITY_WKK',color: '#9768B8'}, {indicator: 'Kolen',data: 'KOLEN',color: '#333'}, {indicator: 'Gas CCGT',data: 'ELECTRICITY_CCGT',color: '#C43C2C'}, {indicator: 'Electricity import',data: 'ELECTRICITY_IMPORT',color: '#FFB300'}],valueLineElements: [{indicator: 'Residual Load Duration Curve Zon+Wind',data: 'RESIDUAL_LOAD_DURATION_CURVE',color: 'black',dash: '4,4',weight: 2}],targetDiv: 'stackGraph_residualLoadDurationCurve',title: 'Residual Load Duration Curve'}
function processResidualLoadDurationCurve () {aggregates.RESIDUAL_LOAD_DURATION_CURVE_ZON_WIND.forEach((function (t, e) {aggregates.RESIDUAL_LOAD_DURATION_CURVE_ZON_WIND[e] = aggregates.POWER_DEMAND_INDUSTRY_TOTAL[e] + aggregates.POWER_DEMAND_UTILITEIT[e] + aggregates.POWER_DEMAND_AGRICULTURE[e] + aggregates.POWER_DEMAND_EIGEN_VERBRUIK[e] + aggregates.ELECTRICITY_DEMAND_GO_APPLIANCES[e] + aggregates.ELEKTROLYSER_CONSOMMATION[e] + aggregates.ELECTRICITY_EXPORT_TOTAL[e] + aggregates.WARMTEPOMP_LUCHTWATER_HYBRIDE_ELECTRICITY_CONSUMPTION[e] + aggregates.WARMTEPOMP_LUCHTWATER_ALLELECTRIC_ELECTRICITY_CONSUMPTION[e] + aggregates.WARMTEPOMP_WATERWATER_ALLELECTRIC_ELECTRICITY_CONSUMPTION[e] + aggregates.WARMTEPOMP_LUCHTLUCHT_ELECTRICITY_CONSUMPTION[e] + aggregates.LI_ION_STORAGE_PRODUCTION[e] - aggregates.ELEKTRICITEITSPRODUCTIE_WIND_ZEE[e] - aggregates.ELEKTRICITEITSPRODUCTIE_WIND_LAND[e] - aggregates.ELEKTRICITEITSPRODUCTIE_ZON[e]})), residualLoadDurationCurve_data = {RESIDUAL_LOAD_DURATION_CURVE: aggregates.RESIDUAL_LOAD_DURATION_CURVE_ZON_WIND,ELECTROLYSIS: aggregates.ELEKTROLYSER_CONSOMMATION.map((t => -Math.abs(t))),ELECTRICITY_EXPORT: aggregates.ELECTRICITY_EXPORT_TOTAL.map((t => -Math.abs(t))),ELECTRICITY_IMPORT: aggregates.ELECTRICITY_IMPORT_TOTAL,ELECTRICITY_CCGT: aggregates.METHANE_CCGT_PRODUCTION_ELECTRICITY,KOLEN: aggregates.COAL_FLEET_PRODUCTION_ELECTRICITY,ELECTRICITY_WKK: aggregates.METHANE_WKK_PRODUCTION_ELECTRICITY,NUCLEAR: aggregates.ELEKTRICITEITSPRODUCTIE_KERNENERGIE};const t = residualLoadDurationCurve_data.RESIDUAL_LOAD_DURATION_CURVE.map(((t, e) => e)).sort(((t, e) => residualLoadDurationCurve_data.RESIDUAL_LOAD_DURATION_CURVE[e] - residualLoadDurationCurve_data.RESIDUAL_LOAD_DURATION_CURVE[t]))
  Object.keys(residualLoadDurationCurve_data).forEach((e => {
    residualLoadDurationCurve_data[e] = t.map((t => residualLoadDurationCurve_data[e][t]))}))}function drawResidualLoadDurationCurve (t) {processResidualLoadDurationCurve();let e = residualLoadDurationCurve_data
  document.getElementById(t.targetDiv).innerHTML = '';let a = parseInt(getComputedStyle(document.querySelector('#' + t.targetDiv)).padding.slice(0, -2)),r = document.querySelector('#' + t.targetDiv).offsetWidth - 2 * a,s = document.querySelector('#' + t.targetDiv).offsetHeight - 2 * a - 70 - 100
  d3.select('#' + t.targetDiv).append('div').attr('id', t.targetDiv + '_title').style('width', r + 'px').style('height', '70px').style('position', 'absolute').style('top', '0px').style('left', '0px'), d3.select('#' + t.targetDiv).append('div').attr('id', t.targetDiv + '_plot').style('width', r + 'px').style('height', s + 'px').style('position', 'absolute').style('top', '70px').style('left', '0px'), d3.select('#' + t.targetDiv).append('div').attr('id', t.targetDiv + '_legend').style('width', r + 'px').style('height', '100px').style('position', 'absolute').style('top', 70 + s + 'px').style('left', '0px'), d3.select('#' + t.targetDiv + '_title_svg').remove(), d3.select('#' + t.targetDiv + '_plot_svg').remove(), d3.select('#' + t.targetDiv + '_legend_svg').remove(), d3.select('#' + t.targetDiv + '_title').append('svg').attr('id', t.targetDiv + '_title_svg').style('width', r + 'px').style('height', '70px'), d3.select('#' + t.targetDiv + '_plot').append('svg').attr('id', t.targetDiv + '_plot_svg').style('width', r + 'px').style('height', s + 'px'), d3.select('#' + t.targetDiv + '_legend').append('svg').attr('id', t.targetDiv + '_legend_svg').style('width', r + 'px').style('height', '100px'), function () {graphViewerCanvas_title = d3.select('#' + t.targetDiv + '_title_svg').append('g'), graphViewerCanvas_plot = d3.select('#' + t.targetDiv + '_plot_svg').append('g'), graphViewerCanvas_legend = d3.select('#' + t.targetDiv + '_legend_svg').append('g');let a = Array.from({length: 8760}, ((t, e) => e)),n = []
    for (i = 0;i < a.length;i++) { for ((T = {}).date = a[i], k = 0;k < t.stackElements.length;k++)e[t.stackElements[k].data] ? T[t.stackElements[k].indicator] = e[t.stackElements[k].data][i] : console.log('WARNING: unknown aggregration key "' + t.stackElements[k].data + '"');n.push(T)}let l = r - 150 - 60,d = s - 70
    graphViewerCanvas_title.append('text').style('font-size', '28px').attr('x', 100).attr('y', 60).text(t.title), function () {let e = 0
      for (i = 0;i < t.stackElements.length;i++)graphViewerCanvas_legend.append('rect').attr('width', 20).attr('height', 20).attr('x', 100 + e).attr('y', 10).attr('fill', t.stackElements[i].color), graphViewerCanvas_legend.append('text').attr('x', 130 + e).attr('y', 25).text(t.stackElements[i].indicator), e += getTextWidth(t.stackElements[i].indicator, '12pt Rijksoverheid') + 50; for (e = 0, i = 0;i < t.valueLineElements.length;i++)graphViewerCanvas_legend.append('line').attr('x1', 100 + e).attr('x2', 100 + e + 35).attr('y1', 55).attr('y2', 55).style('stroke-dasharray', t.valueLineElements[i].dash).style('stroke-width', t.valueLineElements[i].weight).style('stroke', t.valueLineElements[i].color), graphViewerCanvas_legend.append('text').attr('x', 130 + e + 20).attr('y', 60).text(t.valueLineElements[i].indicator), e += getTextWidth(t.valueLineElements[i].indicator, '12pt Rijksoverheid') + 70}(), e = n;const o = Object.keys(n[0]).filter((t => 'date' !== t))
    RLDCurveCategories = o;d3.timeParse('%Y/%m/%d %H:%M');const g = d3.stack().keys(o).order(d3.stackOrderNone).offset(d3.stackOffsetDiverging)(e)
    var E = d3.scaleLinear().domain([0, 8760]).range([0, l])
    y = d3.scaleLinear().range([d, 0]);var _ = d3.area().x((function (t) {return E(t.data.date)})).y0((function (t) {return y(t[0])})).y1((t => y(t[1])))
    d3.scaleOrdinal().domain(o).range(d3.schemeCategory10);E.domain(d3.extent(e, (function (t) {return t.date}))), y.domain([d3.min(g, (t => d3.min(t, (t => t[0])))), d3.max(g, (t => d3.max(t, (t => t[1]))))]);graphViewerCanvas_plot.append('g').attr('class', 'grid').call(d3.axisLeft(y).ticks(5).tickSize(-l).tickFormat('')).attr('fill', 'white').attr('transform', 'translate(100,35)');let C = []
    t.stackElements.forEach((t => {
      C.push(t.color)})), graphViewerCanvas_plot.append('g').selectAll('path').data(g).enter().append('path').attr('id', 'graphPath_' + t.targetDiv).attr('fill', (function (t, e) {return C[e]})).attr('d', _).attr('transform', 'translate(100,35)'), ypos = d + 35, graphViewerCanvas_plot.append('g').attr('transform', 'translate(100,' + ypos + ')').style('font-size', '14px').call(d3.axisBottom(E).ticks(10).tickFormat(d3.format('d'))), graphViewerCanvas_plot.append('g').call(d3.axisLeft(y).ticks(5)).style('font-size', '14px').attr('transform', 'translate(100,35)');var p = s / 2 + 30
    graphViewerCanvas_plot.append('text').attr('x', 20).attr('y', 50).text('MW(h)').style('text-anchor', 'middle').attr('transform', 'translate(-15,' + p + ')rotate(-90)');let c = []
    for (k = 0;k < t.valueLineElements.length;k++) {var T
      for ((T = {}).date = a, T.data = [], T.indicator = t.valueLineElements[k].indicator, T.color = t.valueLineElements[k].color, T.dash = t.valueLineElements[k].dash, T.weight = t.valueLineElements[k].weight, i = 0;i < T.date.length;i++)residualLoadDurationCurve_data[t.valueLineElements[k].data] ? T.data.push(residualLoadDurationCurve_data[t.valueLineElements[k].data][i]) : (console.log('WARNING: unknown aggregration key "' + t.valueLineElements[k].data + '"'), T.data.push(0));c.push(T)}let u = []
    for (i = 0;i < c.length;i++) for (u.push({indicator: c[i].indicator,color: c[i].color,dash: c[i].dash,weight: c[i].weight,data: []}), u[c[i].indicator] = [], k = 0;k < c[i].date.length;k++)u[i].data.push({x: c[i].date[k],y: c[i].data[k]});var L = d3.line().x((function (t) {return E(t.x)})).y((function (t) {return y(parseFloat(t.y))})),I = graphViewerCanvas_plot.append('g')
    for (i = 0;i < u.length;i++) {var R = u[i].color,v = u[i].dash,D = u[i].weight
      I.append('path').attr('class', 'line').attr('fill', 'none').style('stroke', R).style('stroke-width', D).style('stroke-dasharray', v).attr('d', L(u[i].data)).attr('transform', 'translate(100,35)')}}()}updateGraphViews.push({config: residualLoadDurationCurveStackgraphConfig,targetDiv: 'stackGraph_residualLoadDurationCurve',caller: 'residualLoadDurationCurve'})
